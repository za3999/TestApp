package com.test.lib.dynamic_programming;

/**
 * 概念
 * <p>
 * 后一个结果是基于前面的结果产生的（后面的结果与前面的结果有相关性，可以由前面的结果推算出来）
 * 用一句话解释动态规划就是 “记住你之前做过的事”，如果更准确些，其实是 “记住你之前得到的答案”
 * <p>
 * 分析
 * 对于一个动态规划问题，我们只需要从两个方面考虑，那就是 找出问题之间的联系，以及 记录答案，
 * 这里的难点其实是找出问题之间的联系，记录答案只是顺带的事情，利用一些简单的数据结构就可以做到。
 * <p>
 * 算法流程
 * <p>
 * 问题拆解，找到问题之间的具体联系
 * 状态定义
 * 递推方程推导（转移方程
 * <p>
 * 问题拆解
 * “1+1+1+1+1+1+1+1” 得出答案是 8，那么如何快速计算 “1+ 1+1+1+1+1+1+1+1”。
 * 我们首先可以对这个大的问题进行拆解，这里我说的大问题是  1 + “8 个 1 相加的答案”
 * <p>
 * 状态定义
 * 当前问题的答案就是当前的状态。
 * 基于上面的问题拆解，你可以发现两个相邻的问题的联系其实是
 * 后一个问题的答案 = 前一个问题的答案 + 1，这里，状态的每次变化就是 +1。
 * <p>
 * 递推方程
 * 就是 dp[i] = dp[i - 1] + 1。
 * 这里的 dp[i] 记录的是当前问题的答案，也就是当前的状态，dp[i - 1] 记录的是之前相邻的问题的答案，也就是之前的状态，它们之间通过 +1 来实现状态的变更。
 *
 *
 * 动态规划其实和分治策略是类似的，也是将一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。
 * 区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解，于是我们想到将这些子问题的解存储起来，当下次再次求解这个子问题时，直接拿过来就是。
 * 其实就是说，动态规划所解决的问题是分治策略所解决问题的一个子集，只是这个子集更适合用动态规划来解决从而得到更小的运行时间。
 * 即用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了。因此，分治策略一般用来解决子问题相互对立的问题，称为标准分治，而动态规划用来解决子问题重叠的问题。
 *
 * 与「分治策略」「动态规划」概念接近的还有「贪心算法」「回溯算法」
 */

public class AA_remark {
    public static void main(String[] args) {
        System.out.println("result:" + dpExample(450));
    }

    public static int dpExample(int n) {
        int[] dp = new int[n + 1];  // 多开一位用来存放 0 个 2 相加的结果
        dp[0] = 0;      // 0 个 2 相加等于 0
        for (int i = 1; i <= n; ++i) {
            dp[i] = dp[i - 1] + 2;
        }
        return dp[n];
    }
}
