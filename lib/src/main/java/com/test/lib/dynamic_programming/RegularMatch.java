package com.test.lib.dynamic_programming;

/**
 * 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和'*' 的正则表达式匹配。
 * <p>
 * '.' 匹配任意单个字符
 * '*' 匹配零个或多个前面的那一个元素
 * 所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。
 * <p>
 * 说明:
 * <p>
 * s 可能为空，且只包含从a-z 的小写字母。
 * <p>
 * p 可能为空，且只包含从a-z 的小写字母，以及字符 .和 *。
 * <p>
 * 示例 1:
 * <p>
 * 输入:
 * s = "aa"
 * p = "a"
 * 输出: false
 * 解释: "a" 无法匹配 "aa" 整个字符串。
 * 示例 2:
 * <p>
 * 输入:
 * s = "aa"
 * p = "a*"
 * 输出: true
 * 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
 * 示例 3:
 * <p>
 * 输入:
 * s = "ab"
 * p = ".*"
 * 输出: true
 * 解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
 * 示例 4:
 * <p>
 * 输入:
 * s = "aab"
 * p = "c*a*b"
 * 输出: true
 * 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
 * 示例 5:
 * <p>
 * 输入:
 * s = "mississippi"
 * p = "mis*is*p*."
 * 输出: false
 *
 * 解法
 *
 * 我们假设当前问题是考虑 s 的第 i 个字母，p 的第 j 个字母，所以这时的子问题是 s[0…i] 和 p[0…j] 是否匹配：
 *
 * p[j] 是字母，并且 s[i] == p[j]，当前子问题成立与否取决于子问题 s[0…i-1] 和 p[0…j-1] 是否成立
 *
 * p[j] 是 ‘.’，当前子问题成立与否取决于子问题 s[0…i-1] 和 p[0…j-1] 是否成立
 *
 * p[j] 是字母，并且 s[i] != p[j]，当前子问题不成立
 *
 * p[j] 是 ‘*’，s[i] == p[j – 1]，或者 p[j – 1] == ‘.’， 当前子问题成立与否取决于子问题 s[0…i-1] 和 p[0…j] 是否成立
 *
 * p[j] 是 ‘*’，s[i] != p[j – 1]，当前子问题正确与否取决于子问题 s[0…i] 是否匹配 p[0,…j-2]
 *
 *
 * 字符串匹配类动态规划的总结和思考
 * 一般来说，对于字符串匹配的问题中，输入参数都会有两个字串，如果确定了这道题的问题是可以分解成一系列子问题，
 * 那么就可以考虑使用动态规划求解，可以根据区间来定义状态，一般来说只需要考虑头区间或者是尾区间，这道题中的动态规划解法，
 * 我们就是考虑了头区间，s[0,…i]和p[0,…j] 是否匹配记录在 dp[i+1][j+1] 中，如果你选择尾区间的话，那么遍历的方式需要从后往前，就和之前讲解的记忆化搜索一样。
 * 所以一般的字符串匹配的动态规划的 DP 数组都是二维的，当然也有特例。个人觉得确定了考虑的区间和遍历方向，至少来说在动态规划状态方程的推导上会清晰不少。
 *
 * 接下来就是重点的部分，递推方程的推导，这里没有特别多的技巧，还是那句话，唯手熟尔，无他，要说重点的话，还是在确定当前子问题和前面子问题的联系上吧，
 * 或者你可以这样想 “当前考虑的子问题在什么情况下会变成前面求解过的子问题”。
 *
 * 还是拿这道题举例，上面的 DP 解法我们从前往后遍历，在考虑子问题 s[0,…i]和p[0,…j] 是否匹配，
 * 如果拿掉 s[i] 和 p[j]，这个问题就会变成前面求解过的子问题 s[0,…i-1]和p[0,…j-1]，
 * 如果只拿掉 s[i]，这个问题就会变成前面求解过的子问题 s[0,…i-1]和p[0,…j]，
 * 如果只拿掉 p[j-1,j]，这个问题就会变成前面求解过的子问题 s[0,…i]和p[0,…j-2]，
 * 至于为什么有些可以拿掉，有些不能，那这个只能根据题意来分析了，相信通过前面的分析应该不难理解。
 *
 * 结合上面的分析，这里列了一些字符串匹配类动态规划的一些注意事项：
 *
 * 注意考虑是否需要考虑空串的情况，如果是的话，一般 DP 数组需要多开一格
 *
 * 在考虑递推方程前，确定子问题的区间和遍历方向
 *
 * 在思考递推方程的时候，重点思考当前子问题怎么变成之前求解过的子问题
 */
public class RegularMatch {

    public static void main(String[] args) {
        System.out.println("result:" + isMatch("aa", "a*"));

    }

    public static boolean isMatch(String s, String p) {
        if (s.equals(p)) {
            return true;
        }

        char[] sArr = s.toCharArray();
        char[] pArr = p.toCharArray();

        // dp[i][j] => is s[0, i - 1] match p[0, j - 1] ?
        boolean[][] dp = new boolean[sArr.length + 1][pArr.length + 1];

        dp[0][0] = true;

        for (int i = 1; i <= pArr.length; ++i) {
            dp[0][i] = pArr[i - 1] == '*' ? dp[0][i - 2] : false;
        }

        for (int i = 1; i <= sArr.length; ++i) {
            for (int j = 1; j <= pArr.length; ++j) {
                if (sArr[i - 1] == pArr[j - 1] || pArr[j - 1] == '.') {
                    // 看 s[0,...i-1] 和 p[0,...j-1]
                    dp[i][j] = dp[i - 1][j - 1];
                }

                if (pArr[j - 1] == '*') {
                    // 看 s[0,...i] 和 p[0,...j-2]
                    dp[i][j] |= dp[i][j - 2];

                    if (pArr[j - 2] == sArr[i - 1] || pArr[j - 2] == '.') {
                        // 看 s[0,...i-1] 和 p[0,...j]
                        dp[i][j] |= dp[i - 1][j];
                    }
                }
            }
        }

        return dp[sArr.length][pArr.length];
    }
}
