package com.test.lib.sort;

/**
 * 时间复杂度 O(nxk)
 * 空间复杂度 O(n+k)
 * 排序方式 Out-place
 * 稳定性 稳定
 * <p>
 * 算法步骤
 * 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零
 * <p>
 * 从最低位开始，依次进行一次排序
 * <p>
 * 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列
 * <p>
 * <p>
 * 开门见山，基数排序是内排序中性格比较怪异的一种，它无需比较和交换，而是按位分配和收集。通俗地讲就是，对各元素先按个位上的数值排序，接着十位，百位……直到最大元素的最高位，从而排序完成。具体算法如下
 *   1. 求最大位数。由于基数排序是按位排序，所以先要确定最大位数，才能知道排序的趟数。求最大位数的方法是求最大元素的最高位，用循环做比较简单。
 *   2. 分配。由于每位的取值范围是0-9，因此需要十个容器来装，我们一般用十个队列即可，这十个队列标号为0-9。对于每一趟，我们取每一个元素在该位的数值依次入队。
 *   3. 收集。在一趟排序完成后，我们按顺序从0-9队列中依次出队收集元素。
 *   4. 继续进行分配和收集，直到最大位数排序完成。
 */
public class RadixSort {

    public static void sort(int[] arr) {
        //todo
    }

    public static void main(String[] args) {
        int[] arr = new int[]{2, 3, 5, 1, 23, 6, 78, 34, 23, 4, 5, 78, 34, 65, 32, 65, 76, 32, 76, 1, 9};
        sort(arr);
        for (int i : arr) {
            System.out.print(i + " ");
        }
    }

}
